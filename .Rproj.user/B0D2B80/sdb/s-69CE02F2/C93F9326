{
    "contents" : "#########################################\n## COLLABORATIVE FILTERING\n#########################################\n\n\n# optim() takes in the initial values as a vector, but we need to work on them as matrices\nvec2matrix <- function(initial_values, Y, MISSING, nq, ns, nf){\n  X_length <- nq * nf\n  \n  X <- matrix(initial_values[1:X_length], nrow = nq)\n  THETA <- matrix(initial_values[(X_length + 1):length(initial_values)], nrow = ns)\n  DELTA <- THETA %*% t(X) - Y; DELTA[MISSING] <- 0; DELTA <- as.matrix(DELTA)\n  \n  return(list(X, THETA, DELTA))\n}\n\n\n\n# cost function\ncost <- function(initial_values, Y, MISSING, nq, ns, nf, lambda){\n  matrices <- vec2matrix(initial_values, Y, MISSING, nq, ns, nf)\n  \n  X <- matrices[[1]]\n  THETA <- matrices[[2]]\n  DELTA <- matrices[[3]]\n  \n  \n  J <- 0.5 * (sum(DELTA^2, na.rm = T) + lambda * (sum(X^2) + sum(THETA^2)))\n  \n}\n\n\n# gradient of the cost function\ngradient <- function(initial_values, Y, MISSING, nq, ns, nf, lambda, alpha){\n  matrices <- vec2matrix(initial_values, Y, MISSING, nq, ns, nf)\n  \n  X <- matrices[[1]]\n  THETA <- matrices[[2]]\n  DELTA <- matrices[[3]]\n  \n  X_grad <- (t(DELTA) %*% THETA) + lambda * X\n  THETA_grad <- (DELTA %*% X) + lambda * THETA\n  \n  return(c(X_grad, THETA_grad))\n  \n}\n\n\n\n## for 5-fold CV,  \ncol_filt_cv5f <- function(DF){\n  Y <- as.matrix(DF - 2.5)\n  MISSING <- is.na(Y)\n  \n  val_set <- sample(which(MISSING == F))\n  \n  train <- list(Y,Y,Y,Y,Y)\n  test <- list(Y,Y,Y,Y,Y)\n  \n  for(i in 1:5){\n    this_val_set <- val_set[1:length(val_set) %% 5 == i]\n    \n    train[[i]][-this_val_set <- NA\n    test[[i]][this_val_set] <- NA\n  }\n  \n  \n  \n  return(list(train, test))\n  \n}\n\n\n\n## tuning\n\nY_5foldCV <- col_filt_cv(Y, MISSING)\n\nregisterDoParallel()\n\nJ_counter <-\n  foreach(nf = 1:3, .combine = rbind) %:%\n  foreach(fold = 1:5, .combine = rbind) %dopar%{\n    results <- optim(par = runif(nq*nf + ns*nf, -1, 1),\n                     fn = cost,\n                     gr = gradient,\n                     Y = Y_5foldCV[[\"train\"]][[fold]], \n                     MISSING = is.na(Y_5foldCV[[1]][[fold]]), \n                     nq = nq, ns = ns, nf = nf, lambda = 1, alpha = 0.001,\n                     method = \"L-BFGS-B\",\n                     control = list(trace = 1,\n                                    maxit = 1000))\n    test_error <- cost(results$par, Y_5foldCV[[\"test\"]][[fold]], MISSING = is.na(Y_5foldCV[[2]][[fold]]),\n                       nq, ns, nf, lambda)\n    \n    output <- data.frame(nf = nf, fold = fold, Jtrain = results$value, Jtest = test_error)\n    \n  }\n\n\n\ncol_filt_opt_nf <- function(DF, max_latent_features = 7, n_cores = 8) {\n  require(foreach)\n  require(doParallel)\n  require(data.table)\n  \n  nq <- ncol(DF)\n  ns <- nrow(DF)\n  \n  Y <- col_filt_cv5f(DF)\n  \n  registerDoParallel(cores = n_cores)\n  \n  J_counter <-\n    foreach(nf = 1:max_latent_features, .combine = rbind, .multicombine = T, .packages = \"data.table\") %:%\n    foreach(fold = 1:5, .combine = rbind) %dopar% {\n      \n      results <- optim(par = runif(nq*nf + ns*nf, -1, 1),\n                       fn = cost,\n                       gr = gradient,\n                       Y = Y[[\"train\"]][[fold]], \n                       MISSING = is.na(Y[[\"train\"]][[fold]]), \n                       nq = nq, \n                       ns = ns, \n                       nf = nf, \n                       lambda = 1, \n                       alpha = 0.001,\n                       method = \"L-BFGS-B\",\n                       control = list(trace = 1,\n                                      maxit = 1000))\n      \n      test_error <- cost(results$par, \n                         Y[[\"test\"]][[fold]], \n                         MISSING = is.na(Y[[\"test\"]][[fold]]),\n                         nq = nq, \n                         ns = ns, \n                         nf = nf, \n                         lambda = 1)\n      \n      output <- data.table(latent_features = nf, fold = fold, training_cost = results$value, test_cost = test_error)\n      \n    }\n  \n  registerDoSEQ()\n  \n  \n  return(J_counter)\n}\n\n\n",
    "created" : 1463298101095.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "2632592788",
    "id" : "C93F9326",
    "lastKnownWriteTime" : 1463321131,
    "path" : "C:/Users/Jason/Projects/pisa-dispositions/Scripts/0_functions_col_filt.R",
    "project_path" : "Scripts/0_functions_col_filt.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}